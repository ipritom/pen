# শূন্য থেকে STM32 শেখা

অনেকের মত আমারও এমবেডেড প্রোগ্রামিং-এর হাতে খড়ি হয় Arduino প্লাটফর্মে। আরডুইনো খুবই ইন্টারেস্টিং এমবেডেড প্রোগ্রামিং প্লাটফর্ম যেখানে আরডুইনোর নিজেস্ব বোর্ড ছাড়াও আরও হাজার হাজার বোর্ডে সহজেই প্রোগ্রাম করে প্রজেক্ট করে ফেলা যায়। 

খুব দ্রুত এবং খুব সহজেই প্রোজেক্ট করার জন্য আরডুইনো প্লাটফর্মের তুলনা নাই। তবে আরডুইনো প্লাটফর্ম মূলত শিক্ষানবিসদের টার্গেট করে বানানো। তাই এখানে এমবেডেড প্রোগ্রামিং-এর অনেক জটিলতা আড়াল করে ফেলা হয়েছে। এই কারণে সেখানে লেখা কোড ডিপ লেভেলে গিয়ে অপটিমাইজ করা খুব একটা সহজ না। লাইব্রেরির উপর নির্ভরশীলতা বেড়ে যায়। সেই সাথে একটা মাইক্রোকন্ট্রোলার ইউনিট (MCU) কিভাবে কাজ করে তা গভীরভাবে বোঝার সুযোগ নাই।

তাছাড়া ইন্ডাস্ট্রিতে এপ্লিকেশন এবং দামের উপর ভিত্তি করে অনেক রকমের MCU ইউজ করা হতে পারে। ধরা যাক, নতুন একটা কোম্পানি আপনাকে MCU অফার করলো যেটা বাজারে চলমান চিপগুলা থেকে দামে কম এবং পারফরম্যান্স ওই প্রাইস রেঞ্জে অনেক ভাল। আপনি হয়তো এই নতুন MCU এর জন্য আরডুইনো প্লাটফর্মে সাপোর্ট পাবেন না। তখন? এই জন্য MCU এর ব্যাকএন্ড বোঝা জরুরী। কিভাবে MCU এর ভিতরটা বুঝতে হয় তা খুবই অল্প কথায় এই লেখায় আলোচনা করা হবে। একটা MCU এর কাজকারবার ভালোভাবে বোঝা গেলে যেকোনো MCU নিয়েই কাজ করা সম্ভব।

এই লেখায় আমি কথা না বাড়িয়ে সরাসরি চলে যাব আরডুইনোর কিছু সহজ সরল ফাংশন কিভাবে একদম স্ক্র্যাচ থেকে লেখা যায় সেই উপায় অনুসন্ধানে। এই কাজের জন্য আমি বেছে নিচ্ছি STM32 এর একটা MCU। এখানে [Blue Pill](https://stm32-base.org/boards/STM32F103C8T6-Blue-Pill.html)
 ব্যবহার করে উদাহরণ দেয়া হবে। এই বোর্ডে [STM32F103C8T6](https://www.st.com/en/microcontrollers-microprocessors/stm32f103c8.html) চিপ ইউজ করা হয়েছে।

এই লেখাটা মূলত রেজিস্টার বেজড প্রোগ্রামিং নিয়ে, যেখানে দেখানো হবে মাইক্রোকন্ট্রোলারের রেজিস্টারগুলা ম্যানিপুলেট করে কিভাবে একটা আউটপুট আনা যায়। আরডুইনোর IDE এর ব্যাকএন্ড মূলত ওভাবেই লেখা। কিন্তু আমরা কিভাবে নিজেরা ওই ব্যাকএন্ড বুঝতে পারি এবং লিখতে পারি সেটা দেখব। যেমনঃ কিভাবে একটা GPIO পিন high-low করা যায়, কিভাবে মাইক্রোকন্ট্রোলারে `printf()` ফাংশান লেখা যায়, PWM সিগনাল জেনারেট করা যায়, ইত্যাদি।

## গুরুত্বপূর্ণ টুলস

এই লেখায় বর্ণিত টেকনিক হুবহু এপ্লাই করার জন্য নিচের টুলসগুলা প্রয়োজনঃ

* Blue Pill board.

* Keil MDK-Arm অথবা যদি VScode এ Keil Extension পেতে চান তাহলে এই আর্টিকেল ফলো করতে পারেন - [How to Setup Keil inside VSCode](https://mpritom.com/silicon/keil_vscode.md).

* ST-Link V2 - বোর্ডে প্রোগ্রাম আপলোড দেয়ার জন্য। 

## কোথা থেকে শুরু করা যায় 

রেজিস্টার বেজড প্রোগ্রামিং শুরু করার প্রথম ধাপ হচ্ছে, আপনার কাছে যেই বোর্ড বা পিসিবি আছে সেখানে কোন MCU ব্যবহার করা হয়েছে সেটা দেখা। 

এরপর এই MCU আপনি কিভাবে ব্যবহার করবেন সেই সম্পর্কিত ডকুমেন্টস কালেক্ট করা। 

STM32 এর MCU গুলো নিয়ে কাজ করার জন্য ২-টা গুরুত্বপূর্ণ ডকুমেন্ট হলঃ


* [ডেটাশিট](https://www.st.com/resource/en/datasheet/cd00161566.pdf) 

* [রেফারেন্স ম্যানুয়াল](https://www.st.com/resource/en/reference_manual/rm0008-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf)

ST.com সাইটে তাদের প্রোডাক্ট সম্পর্কিত সকল ডকুমেন্ট সুন্দর করে সাজানো থাকে। জাস্ট MCU এর মডেল নাম্বার লিখে গুগলে সার্চ করলে সহজেই খুঁজে পাওয়া যায়। 

# ডেটাশিট
ডেটাশিটের প্রথম পেজ থেকে এক নজরে বুঝে নেয়া যায় এই MCU তে কি কি ফিচার আছে। 

যেমনঃ ম্যাক্সিমাম ক্লক স্পিড কত হতে পারে। STM32F103C8T6 এর ক্ষেত্রে 72 MHz। ফ্লাস মেমরি কত হতে পারে। কতগুলা Timer হার্ডওয়ারে দেয়া আছে এবং সেইগুলা কত বিটের। 

যেকোনো নতুন MCU নিয়ে কাজ করার শুরুতে সেইটার ডেটাশিট ভালোভাবে স্টাডি করা জরুরী।

ডেটাশিট স্টাডি করার সময় লক্ষণীয় যে এখানে টাইটেলে **STM32F103x8 ,STM32F103xB** লেখা থাকে। মূলত এইটা ফ্যামিলির নাম। প্রতিটা MCU এর মডেলের জন্য আলাদা আলাদা ডেটাশিট পাবলিশ না করে সাধারণত একটা ফ্যামিলি সিরিজের জন্য কমন ডেটাশিট পাবলিশ করা হয়। স্টাডি করার সময় এই ব্যাপারটা খেয়াল রাখা জরুরী। 

![](https://res.cloudinary.com/djqcqqueb/image/upload/f_auto,q_auto/v1/stm32_chap0/dt5dfld94zyuaylale5v)<br>
*<small>Data Sheet - Front Page</small>*

যেমন মেমোরি সেকশনে ফ্লাশ র‍্যামের সাইজ 64 or 128 কিলোবাইট উল্লেখ আছে। অর্থাৎ এই দুইটার যেকোনো একটা হতে পারে। ডাটাশিটের কোথাও না কোথাও উল্লেখ থাকবে এই ফ্যামিলির অন্তর্গত STM32F103C8T6 চিপে এই ফ্লাশ র‍্যামের সাইজ কত। 

# রেফারেন্স ম্যানুয়াল 

STM32 এর রেফারেন্স ম্যানুয়াল প্রোগ্রাম লেখার জন্য খুবই গুরত্বপূর্ণ। এখানে সকল রেজিস্টারের বিস্তারিত বর্ণনা দেয়া থাকে। কোন বিট (bit)-এর কাজ কি, কোনো একটা পেরিফেরাল একটিভ করতে কোথায় কোন রেজিস্টার ম্যানিপুলেট করা লাগবে - এইসব ডিটেইল বর্ণনা এখানে পাওয়া যাবে। 

![](https://res.cloudinary.com/djqcqqueb/image/upload/f_auto,q_auto/v1/stm32_chap0/vkew9nsvmwrpydeg40vl)<br>
*<small>Reference Manual (RM) : 7.3.8 APB1 peripheral clock enable register </small>*

একটা উদাহরণ হিসেবে রেফারেন্স ম্যানুয়ালের একটি পেজ দেখানো হলো। এখানে আমরা `RCC` এর আন্ডারে `APB1ENR` রেজিস্টারের ৩২ টা বিটের সংক্ষিপ্ত বর্ণনা দেখতে পাচ্ছি। RCC এর আন্ডারে এরকম আরও অনেক রেজিস্টার আছে যা এক নজরে প্রতি অধ্যায়ের শেষে দেয়া `register map` সেকশন থেকে দেখে নিতে পারেন।

এই লেখার পরবর্তীতে আমরা একটা উদাহরণের মাধ্যমে বুঝব কিভাবে ডাটাশিট এবং রেফারেন্স ম্যানুয়াল ঘেটে একটা GPIO পিন High বা Low করা যায়। 

যদি আর্ডুইনোতে আপনার অভিজ্ঞতা থাকে তাহলে নিশ্চয়ই মনে আছে - `pinMode()` ফাংশান দিয়ে আপনি একটা পিন সিলেক্ট করেন এবং ওইটা আউটপুট পিন নাকি ইনপুট পিন তা বলে দেন। পরে `digitalWrite()` ফাংশান দিয়ে ওই পিন High/Low করা যায়। তবে এই অভিজ্ঞতা না থাকলেও অসুবিধা নাই, বরং ভাল। কারণ নতুন কিছু শেখার শুরুতে ব্রেইনে প্রিভিয়াস জ্ঞ্যানের বোঝা না থাকা আরও বেশি সুবিধার। 

## STM32F103C8T6 সংক্ষিপ্ত বিবরণ

ডেটাশিটে STM32F103xx ফ্যামিলির Block Diagram দেয়া আছে যেখান থেকে আমরা এক নজরে দেখে নিতে পারি এই চিপের অভ্যন্তরীণ গঠন কেমন। এটা আমাদের প্রয়োজন হবে প্রোগ্রাম করার সময়।

![](https://res.cloudinary.com/djqcqqueb/image/upload/f_auto,q_auto/v1/stm32_chap0/trhyhbeanjq2huza5tud)<br>
*<small>Data Sheet (DS) - Figure 1</small>*

Arm চিপগুলাতে ২ ধরণের বাস থাকে। 
* APB : Advanded Peripheral Bus 
* AHB: Advanced High-performance Bus 

**APB** হল একটি low-bandwidth, low-power বাস, যা সাধারণত ধীর গতির পেরিফেরাল (যেমন: Timer, UART, GPIO, SPI, I2C ইত্যাদি) সংযোগের জন্য ব্যবহৃত হয়।

**AHB** হলো high-bandwidth, high-performance বাস, যা বেশি গতির ডেটা ট্রান্সফার প্রয়োজন এমন ক্ষেত্রে ব্যবহৃত হয়, যেমনঃ CPU এবং মেমরির মধ্যে দ্রুতগতিতে যোগাযোগ স্থাপনের জন্য এই বাস ব্যবহার করা যায়। 

STM32 এর চিপে **APB** এবং **AHB** এর একাধিক লাইন থাকতে পারে। ডাটাশিটের *Figure 1* একটু জুম করে দেখলে আমরা দেখব APB বাসের দুইটা  লাইন আছে। এর মধ্যে APB2 এ GPIO গুলা কানেক্টেড এবং APB1 এর সাথে টাইমারগুলা কানেক্টেড আছে। 

![](https://res.cloudinary.com/djqcqqueb/image/upload/f_auto,q_auto/v1/stm32_chap0/mhhmvzwnagnhsbcu1i44)<br>
*<small>DS - Figure 1 - GPIO এবং Timer কানেকশন ABP বাসের সাথে</small>*

এখন GPIO নিয়ন্ত্রণ করতে যাওয়ার আগে আমাদের STM32 এর চীপ ডিজাইন সম্পর্কে চমৎকার কিছু জানা থাকা দরকার। 

* STM32 মাইক্রোকন্ট্রোলার ARM Cortex-M আর্কিটেকচারের উপর ভিত্তি করে তৈরি, যা 32-bit RISC (Reduced Instruction Set Computing) প্রসেসর ব্যবহার করে।

* 32-bit Architecture হওয়ার জন্য রেফারেন্স ম্যানুয়ালে খেয়াল করবেন যে সব রেজিস্টার 32-bit এর। 

* যেহেতু 32-bit Architecture তাই একটা CPU cycle এ 32-bit ডাটা প্রেসেস করতে পারে। 
 
* STM32 মাইক্রোকন্ট্রোলারে প্রতিটি পেরিফেরালে আলাদাভাবে **Clock Gating** করা হয়। অর্থাৎ কোনো I/O পোর্ট বা পেরিফেরাল ইউজ করতে চাইলে আলাদা করে ওইখানে ক্লক লাগাতে হবে. আরেকটু ফরমালভাবে বললে বলতে হয় clock enable করতে হবে। 

* যেহেতু by default ক্লক লাগানো থাকে না সব জায়গায়, এটার জন্য এই MCU গুলা খুবই পাওয়ার এফিশিয়েন্ট হয়। অনেক চীপ আছে যেগুলাতে এরকম আলদা করে সব জায়গায় ক্লক এনাবল করা লাগে না। কিন্তু STM32 এর চীপগুলাতে অতিরিক্ত নিয়ন্ত্রণ ক্ষমতা দেয় ইউজারকে। তবে এইক্ষেত্রে মনে রাখা দরকার - *with great power comes great responsibility*.


এখন এই বেসিক জানার পর আমরা প্রস্তুত GPIO নিয়ন্ত্রণের শেখার জন্য।

## GPIO নিয়ন্ত্রণ   

Blue Pill বোর্ডে বিল্ট-ইন ইউজার LED সংযুক্ত **PC13** পিনে। অর্থাৎ GPIO এর C পোর্টের এর ১৩ নাম্বার পিন। ব্লক ডায়াগ্রাম (DS : Figure 1) থেকে আমরা জানি এরকম A থেকে E পর্যন্ত পোর্ট থাকতে পারে এবং প্রতি পোর্টে ১৬ টা পিন থাকতে পারে।

GPIO নিয়ন্ত্রণে জন্য সহজ তিনটা ধাপ, যা মূলত প্রায় সব চীপের জন্যই কমন। 


* **ধাপ-১ :** GPIO পিনের জন্য Clock Enable করতে হবে। 

* **ধাপ-২ :** GPIO পিনের Mode সেট করতে হবে।

* **ধাপ-৩ :** GPIO পিন High/Low করে LED অন-অফ করতে হবে। 

এবার সময় এসেছে রেফারেন্স ম্যানুয়ালের শক্তি কাজে লাগানোর। আমরা এই তিনটি ধাপ অনুসারণের জন্য রেফারেন্স ম্যানুয়ালের কোথায় কোথায় যেতে হবে তা দেখব।

### ধাপ-১ : GPIO পিনে Clock Enable করা

STM32 এর রেফারেন্স ম্যানুয়ালে, কোনো GPIO বা Peripheral এ ক্লক লাগানোর ব্যাপারগুলা থাকে **Reset and clock control (RCC)** এর অধ্যায়ে।

GPIO গুলা যেহেতু APB বাসে কানেক্টেড তাই আমাদের APB বাস লাইনে ক্লক চালু করতে হবে। ডাটাশিট থেকে আমরা জানি, GPIO পোর্টগুলা APB2 এ কানেক্টেড। এই বাস লাইনে ক্লক এনাবল করার আমাদের রেফারেন্স ম্যানুয়ালে খুঁজে বের করতে হবে `RCC` এর কোন রেজিস্টার দিয়ে এই বাস লাইনের ক্লক এনাবল করা যায়। 

![](https://res.cloudinary.com/djqcqqueb/image/upload/f_auto,q_auto/v1/stm32_chap0/j78xnvmf4vnvknrwcdxg)<br>
*<small>RM : 7.3.7 APB2 peripheral clock enable register (RCC_APB2ENR)</small>*

রেজিস্টার ডেসক্রিপশন থেকে আমরা দেখতে পাচ্ছি যে `RCC_APB2ENR` রেজিস্টারের 4th bit সেট (1) করলে আমরা জায়গা মত ক্লক এনাবেল করতে পারছি। 

এখান থেকে আমাদের রেজিস্টারের বিট ম্যানিপুলেশন শুরু। এই ক্ষেত্রে আমরা বিটওয়াইজ অপারেশন কাজে লাগাবো, যাতে অন্য কোনো বিট পরিবর্তন না করে আমরা সহজেই একটা বিট সেট (1) বা রিসেট (0) করতে পারি। যদি আমরা বিটওয়াইজ অপারেশন না করি তাহলে আমাদের ৩২ বিটের নাম্বার সেট করতে হবে সরাসরি ওই রেজিস্টারে। একইসাথে অন্যান্য বিটের ডিফল্ট ভ্যালুও মেইন্টেইন করতে হবে। কিন্তু এরকম ম্যানুয়ালি রেজিস্টারের ভ্যালু সেট করতে যাওয়া কষ্টসাধ্য। তাই bitwise operation -এর শক্তি কাজে লাগাতে হবে আমাদের।

একটা নির্দিষ্ট বিট সেট করার জন্য bitwise OR assignment operation করতে হবে। `RCC_APB2ENR` রেজিস্টারের 4th bit সেট (1) করার কৌশল নিচে দেখানো হলো।

```c
 RCC->APB2ENR |= (1<<4);
```

### ধাপ-২ : GPIO পিনকে Output Mode-এ সেট করা

আমরা এখানে GPIO এর পোর্ট C এর ১৩ নাম্বার পিনকে আউটপুট হিসেবে সেট করব। এতে আমরা প্রোগ্রাম থেকে এই পিনে লজিক হাই বা লো করতে পারব। একইভাবে ডাটাশিট স্টাডি করে ইনপুট হিসেবে সেট করা সম্ভব।

GPIO তে Mode কনফিগারেশন ঠিক করার জন্য আমাদের যেতে হবে Port Configuration Register সেকশনে।

![](https://res.cloudinary.com/djqcqqueb/image/upload/f_auto,q_auto/v1/stm32_chap0/hzinyxw5imts3he1vthk)<br>
*<small>RM : 9.2.2 Port configuration register high (GPIOx_CRH)</small>*

এখানে কিছু গুরুত্বপূর্ণ ব্যাপার খেয়াল করার আছে। এখানে রিসেট ভ্যালু hex নাম্বার ফরমেটে হিসেবে দেয়া আছে। এখান থেকে আমরা বুঝতে পারছি এখানে সব বিটের মান কিন্তু by default জিরো থাকবে না। রেজিস্টার কনফিগারেশনের সময় এই ব্যাপারগুলা খেয়াল রাখা জরুরি।

ডাটাশিট থেকে আমরা দেখতে পারছি এ `GPIOx_CRH` রেজিস্টার `CNFy` এবং `MODEy` এই দুই রকমের বিটে ভাগ করা। এখানে `y` এর ভ্যালু হচ্ছে পিন নাম্বার। আমরা যেহেতু ১৩ নাম্বার পিন নিয়ে কাজ করছি তাই এখানে `y=13`। 

অর্থাৎ এই রেজিস্টারে ২০-২৩ নাম্বার বিট আমাদের ম্যানিপুলেট করতে হবে। 

প্রথমত আউটপুট মোডের জন্য `CNFy` এর দুইটা বিটের ভ্যাল্য `00` হবে যা ২৩ ও ২২ নাম্বার পজিশনে আছে। 

এই দুই বিট ক্লিয়ার বা রিসেট (0) করার জন্য আমাদের **bitwise AND** with **bitwise NOT** ওপারেশন করা লাগবে। এখানে উদাহরণ সহ দেখানো হলো।

```c
GPIOC->CRH &= ~(1<<23);
GPIOC->CRH &= ~(1<<22);
```

এরপর আমরা আউটপুট মোডের জন্য ক্লকের স্পিড সিলেক্ট করতে পারবো। এখানে আমাদের 10 MHz, 2 MHz এবং 50 MHz অপশন আছে। আমরা এখানে 10 MHz সিলেক্ট করছি।

```c
GPIOC->CRH &= ~(1<<21);
GPIOC->CRH |= (1<<20);
```

### ধাপ-৩ : GPIO পিনকে High/Low করা

আমাদের GPIO পোর্ট এবং পিন কনফিগারেশন করা শেষ। এবার সময় আউটপুটে লজিক সেট করার। এই সম্পর্কিত তথ্য আমরা পাবো Port output data register সেকশনে। আমরা দেখতে পারছি `GPIOx` এর আন্ডারে `ODR` নামে একটা রেজিস্টার আছে। 


![](https://res.cloudinary.com/djqcqqueb/image/upload/f_auto,q_auto/v1/stm32_chap0/ijddu6btifsobz2pvc4f)<br>
*<small>RM : 9.2.4 Port output data register (GPIOx_ODR)</small>*

এখান থেকে আমরা বুঝতে পারছি যে `ODR13` বিট আমাদের সেট বা রিসেট করতে হবে Blue Pill এর user LED অন-অফ করার জন্য যা Port C এর 13 নাম্বার পিনের সাথে কানেক্ট করা আছে। 

Blue Pill এর হার্ডওয়ার ডিজাইনে PC13 পিনটা একটিভ লো (active low)। অর্থাৎ, লজিক Low হলে LED ON হবে। তার মানে রেজিস্টারের এই বিটের ভ্যালু রিসেট বা 0 থাকলেই LED জলবে। আমরা একটা ইনফাইনাইট লুপের মধ্যে এই ভ্যালুটা রিসেট রাখতে পারি। 


```c
while (1)
{
    GPIOC->ODR &= ~(1<<13);
}
```

এই পর্যন্ত করার পর আমাদের পুরো কোড অনেকটা এমন হবে। 

```c

#include "RTE_Components.h"
#include CMSIS_device_header

int main() {
    // enable clock in the GPIO Port C Bus
    RCC->APB2ENR |= (1<<4);
    // Pin Configuration
    GPIOC->CRH &= ~(1<<23);
    GPIOC->CRH &= ~(1<<22);
    GPIOC->CRH &= ~(1<<21);
    GPIOC->CRH |= (1<<20);
    // Set GPIO Output Logic as High
    while (1)
    {
        GPIOC->ODR &= ~(1<<13);
    }
    
}

```

আমরা যদি এই প্রোগ্রাম ST-Link V2 দিয়ে Blue Pill বোর্ডে ফ্লাশ করি তাহলে দেখব ইউজার LED ON আছে।

![](https://res.cloudinary.com/djqcqqueb/image/upload/f_auto,q_auto/v1/stm32_chap0/lcfaigpjcaxs9pp89use)<br>
<small>ছবিতে ইউজার LED মার্ক করা আছে। একই সাথে ST Link এর সাথে কোন পিনগুলা কানেক্টেড হবে তা দেখানো হলো</small>



## ক্লিন কোড (অপশনাল)

আমাদের এই কোড আরেকটু পাঠযোগ্য করে লেখা যায়। আমরা এখানে অনেক বিট শিফট অপারেশন করেছি। যেমন (1<<4), এটাকে বলে 1 left shifted by 4। এই অপারেশনগুলার ম্যাক্রো ডেফিনিশন CMSIS এর লাইব্রেরি হেডারে দেয়া আছে। কোড লেখার সুবিধার্থে আমরা ম্যাক্রোডেফিনিশন ব্যবহার করতে পারি। সেই ক্ষেত্রে আমাদের কোডবেজ নিচের মত হবে। 

```c

#include "RTE_Components.h"
#include CMSIS_device_header

int main() {
    // enable clock in the GPIO Port C Bus
    RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
    // Pin Configuration
    GPIOC->CRH &= ~GPIO_CRH_CNF13_1;
    GPIOC->CRH &= ~GPIO_CRH_CNF13_0;
    GPIOC->CRH &= ~GPIO_CRH_MODE13_1;
    GPIOC->CRH |= ~GPIO_CRH_MODE13_0;

    // Set GPIO Output Logic as High
    while (1)
    {
        GPIOC->ODR &= ~GPIO_ODR_ODR13;
    }

}

```


<!-- [stm32, embedded, electronics] -->